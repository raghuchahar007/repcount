# M1: Auth Flow — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build complete phone OTP → JWT auth flow replacing Supabase auth, so users can login and access role-gated pages.

**Architecture:** Server: OTP service (test bypass) → JWT service (access + refresh tokens) → auth routes → auth middleware. Client: AuthContext (in-memory JWT + user state) → Login/VerifyOtp pages → ProtectedRoute → role-based router.

**Tech Stack:** jsonwebtoken, cookie-parser (already installed), Express middleware, React Context + React Router v6

---

### Task 1: OTP Service (server)

**Files:**
- Create: `server/src/services/otp.service.ts`

**Step 1: Create OTP service with test bypass**

```typescript
// server/src/services/otp.service.ts

const TEST_PHONE = process.env.TEST_PHONE || '+919999999999'
const TEST_OTP = process.env.TEST_OTP || '123456'

// In-memory OTP store (for dev). In production, use Redis or the SMS provider's verify API.
const otpStore = new Map<string, { otp: string; expiresAt: number }>()

export function generateOtp(): string {
  return Math.floor(100000 + Math.random() * 900000).toString()
}

export async function sendOtp(phone: string): Promise<{ success: boolean; message: string }> {
  // Test phone bypass — no SMS sent
  if (phone === TEST_PHONE) {
    return { success: true, message: 'OTP sent (test mode)' }
  }

  // TODO: Integrate MSG91/Twilio here for production
  // For now, store OTP in memory for non-test phones too
  const otp = generateOtp()
  otpStore.set(phone, { otp, expiresAt: Date.now() + 5 * 60 * 1000 }) // 5 min expiry
  console.log(`[DEV] OTP for ${phone}: ${otp}`)
  return { success: true, message: 'OTP sent' }
}

export async function verifyOtp(phone: string, otp: string): Promise<boolean> {
  // Test phone bypass
  if (phone === TEST_PHONE && otp === TEST_OTP) {
    return true
  }

  const stored = otpStore.get(phone)
  if (!stored) return false
  if (Date.now() > stored.expiresAt) {
    otpStore.delete(phone)
    return false
  }
  if (stored.otp !== otp) return false

  otpStore.delete(phone) // One-time use
  return true
}
```

**Step 2: Verify server compiles**

```bash
cd server && npx tsc --noEmit
```

Expected: 0 errors

**Step 3: Commit**

```bash
git add server/src/services/otp.service.ts
git commit -m "feat(server): OTP service with test phone bypass"
```

---

### Task 2: JWT Token Service (server)

**Files:**
- Create: `server/src/services/token.service.ts`

**Step 1: Create token service**

```typescript
// server/src/services/token.service.ts
import jwt from 'jsonwebtoken'

const JWT_SECRET = process.env.JWT_SECRET || 'dev-secret-change-me'
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'dev-refresh-secret-change-me'
const JWT_EXPIRY = process.env.JWT_EXPIRY || '15m'
const JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY || '7d'

export interface TokenPayload {
  userId: string
  phone: string
  role: string
}

export function signAccessToken(payload: TokenPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRY })
}

export function signRefreshToken(payload: TokenPayload): string {
  return jwt.sign(payload, JWT_REFRESH_SECRET, { expiresIn: JWT_REFRESH_EXPIRY })
}

export function verifyAccessToken(token: string): TokenPayload {
  return jwt.verify(token, JWT_SECRET) as TokenPayload
}

export function verifyRefreshToken(token: string): TokenPayload {
  return jwt.verify(token, JWT_REFRESH_SECRET) as TokenPayload
}
```

**Step 2: Verify server compiles**

```bash
cd server && npx tsc --noEmit
```

Expected: 0 errors

**Step 3: Commit**

```bash
git add server/src/services/token.service.ts
git commit -m "feat(server): JWT token service (access + refresh)"
```

---

### Task 3: Auth Middleware (server)

**Files:**
- Create: `server/src/middleware/auth.ts`
- Create: `server/src/middleware/roleGuard.ts`
- Create: `server/src/middleware/gymAccess.ts`
- Create: `server/src/middleware/validate.ts`
- Create: `server/src/middleware/errorHandler.ts`

**Step 1: Create auth middleware** — verifies JWT from Authorization header, attaches user to req

```typescript
// server/src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express'
import { verifyAccessToken, TokenPayload } from '../services/token.service'

// Extend Express Request to include user
declare global {
  namespace Express {
    interface Request {
      user?: TokenPayload
    }
  }
}

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Access token required' })
  }

  const token = authHeader.split(' ')[1]
  try {
    const payload = verifyAccessToken(token)
    req.user = payload
    next()
  } catch {
    return res.status(401).json({ error: 'Invalid or expired access token' })
  }
}
```

**Step 2: Create role guard middleware**

```typescript
// server/src/middleware/roleGuard.ts
import { Request, Response, NextFunction } from 'express'

export function requireOwner(req: Request, res: Response, next: NextFunction) {
  if (!req.user || req.user.role !== 'owner') {
    return res.status(403).json({ error: 'Owner access required' })
  }
  next()
}

export function requireMember(req: Request, res: Response, next: NextFunction) {
  if (!req.user || req.user.role !== 'member') {
    return res.status(403).json({ error: 'Member access required' })
  }
  next()
}
```

**Step 3: Create gym access middleware** — verifies the owner owns the gym (replaces RLS)

```typescript
// server/src/middleware/gymAccess.ts
import { Request, Response, NextFunction } from 'express'
import { Gym } from '../models/Gym'

// Extend Express Request to include gym
declare global {
  namespace Express {
    interface Request {
      gym?: InstanceType<typeof Gym>
    }
  }
}

export async function requireGymAccess(req: Request, res: Response, next: NextFunction) {
  try {
    const gymId = req.params.gymId
    if (!gymId) {
      return res.status(400).json({ error: 'Gym ID required' })
    }

    const gym = await Gym.findById(gymId)
    if (!gym) {
      return res.status(404).json({ error: 'Gym not found' })
    }

    if (gym.owner.toString() !== req.user!.userId) {
      return res.status(403).json({ error: 'Not your gym' })
    }

    req.gym = gym
    next()
  } catch {
    return res.status(500).json({ error: 'Failed to verify gym access' })
  }
}
```

**Step 4: Create validation middleware** (Zod-based)

```typescript
// server/src/middleware/validate.ts
import { Request, Response, NextFunction } from 'express'
import { ZodSchema } from 'zod'

export function validate(schema: ZodSchema) {
  return (req: Request, res: Response, next: NextFunction) => {
    const result = schema.safeParse(req.body)
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        details: result.error.flatten().fieldErrors,
      })
    }
    req.body = result.data
    next()
  }
}
```

**Step 5: Create error handler middleware** (replace inline one in app.ts)

```typescript
// server/src/middleware/errorHandler.ts
import { Request, Response, NextFunction } from 'express'

export function errorHandler(err: any, _req: Request, res: Response, _next: NextFunction) {
  console.error('Error:', err.message || err)
  const status = err.status || err.statusCode || 500
  res.status(status).json({
    error: process.env.NODE_ENV === 'production' ? 'Internal server error' : err.message || 'Unknown error',
  })
}
```

**Step 6: Verify server compiles**

```bash
cd server && npx tsc --noEmit
```

Expected: 0 errors

**Step 7: Commit**

```bash
git add server/src/middleware/
git commit -m "feat(server): auth, roleGuard, gymAccess, validate, errorHandler middleware"
```

---

### Task 4: Auth Routes (server)

**Files:**
- Create: `server/src/routes/auth.routes.ts`
- Modify: `server/src/app.ts` — mount auth routes, use errorHandler

**Step 1: Create auth routes**

```typescript
// server/src/routes/auth.routes.ts
import { Router, Request, Response } from 'express'
import { z } from 'zod'
import { User } from '../models/User'
import { sendOtp as sendOtpService, verifyOtp as verifyOtpService } from '../services/otp.service'
import { signAccessToken, signRefreshToken, verifyRefreshToken } from '../services/token.service'
import { validate } from '../middleware/validate'

const router = Router()

const sendOtpSchema = z.object({
  phone: z.string().regex(/^\+91\d{10}$/, 'Phone must be +91 followed by 10 digits'),
})

const verifyOtpSchema = z.object({
  phone: z.string().regex(/^\+91\d{10}$/, 'Phone must be +91 followed by 10 digits'),
  otp: z.string().length(6, 'OTP must be 6 digits'),
})

// POST /api/auth/send-otp
router.post('/send-otp', validate(sendOtpSchema), async (req: Request, res: Response) => {
  try {
    const { phone } = req.body
    const result = await sendOtpService(phone)
    res.json(result)
  } catch (err: any) {
    res.status(500).json({ error: 'Failed to send OTP' })
  }
})

// POST /api/auth/verify-otp
router.post('/verify-otp', validate(verifyOtpSchema), async (req: Request, res: Response) => {
  try {
    const { phone, otp } = req.body

    const isValid = await verifyOtpService(phone, otp)
    if (!isValid) {
      return res.status(400).json({ error: 'Invalid or expired OTP' })
    }

    // Find or create user
    let user = await User.findOne({ phone })
    if (!user) {
      user = await User.create({ phone, role: 'member' })
    }

    const tokenPayload = {
      userId: user._id.toString(),
      phone: user.phone,
      role: user.role,
    }

    const accessToken = signAccessToken(tokenPayload)
    const refreshToken = signRefreshToken(tokenPayload)

    // Set refresh token as httpOnly cookie
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      path: '/',
    })

    res.json({
      accessToken,
      user: {
        id: user._id,
        phone: user.phone,
        role: user.role,
        full_name: user.full_name,
      },
    })
  } catch (err: any) {
    console.error('verify-otp error:', err)
    res.status(500).json({ error: 'Failed to verify OTP' })
  }
})

// POST /api/auth/refresh
router.post('/refresh', async (req: Request, res: Response) => {
  try {
    const token = req.cookies?.refreshToken
    if (!token) {
      return res.status(401).json({ error: 'Refresh token required' })
    }

    const payload = verifyRefreshToken(token)

    // Re-fetch user to get latest role
    const user = await User.findById(payload.userId)
    if (!user) {
      return res.status(401).json({ error: 'User not found' })
    }

    const tokenPayload = {
      userId: user._id.toString(),
      phone: user.phone,
      role: user.role,
    }

    const accessToken = signAccessToken(tokenPayload)
    const newRefreshToken = signRefreshToken(tokenPayload)

    res.cookie('refreshToken', newRefreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: '/',
    })

    res.json({
      accessToken,
      user: {
        id: user._id,
        phone: user.phone,
        role: user.role,
        full_name: user.full_name,
      },
    })
  } catch {
    return res.status(401).json({ error: 'Invalid refresh token' })
  }
})

// POST /api/auth/logout
router.post('/logout', (_req: Request, res: Response) => {
  res.clearCookie('refreshToken', { path: '/' })
  res.json({ success: true })
})

export default router
```

**Step 2: Update app.ts** — mount auth routes and use errorHandler

Replace the entire `server/src/app.ts` with:

```typescript
// server/src/app.ts
import express from 'express'
import cors from 'cors'
import cookieParser from 'cookie-parser'
import authRoutes from './routes/auth.routes'
import { errorHandler } from './middleware/errorHandler'

const app = express()

app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:5173',
  credentials: true,
}))
app.use(express.json())
app.use(cookieParser())

// Health check
app.get('/api/health', (_req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() })
})

// Routes
app.use('/api/auth', authRoutes)

// Global error handler (must be last)
app.use(errorHandler)

export default app
```

**Step 3: Verify server compiles**

```bash
cd server && npx tsc --noEmit
```

Expected: 0 errors

**Step 4: Commit**

```bash
git add server/src/routes/auth.routes.ts server/src/app.ts
git commit -m "feat(server): auth routes (send-otp, verify-otp, refresh, logout)"
```

---

### Task 5: AuthContext (client)

**Files:**
- Create: `client/src/contexts/AuthContext.tsx`

**Step 1: Create AuthContext** — manages JWT, user state, loading, login/logout

```tsx
// client/src/contexts/AuthContext.tsx
import { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react'
import { refreshToken as refreshTokenApi, logout as logoutApi } from '@/api/auth'
import { setAccessToken } from '@/api/axios'

interface AuthUser {
  id: string
  phone: string
  role: 'owner' | 'member' | 'admin'
  full_name: string | null
}

interface AuthContextValue {
  user: AuthUser | null
  loading: boolean
  login: (accessToken: string, user: AuthUser) => void
  logout: () => Promise<void>
}

const AuthContext = createContext<AuthContextValue>({
  user: null,
  loading: true,
  login: () => {},
  logout: async () => {},
})

export function useAuth() {
  return useContext(AuthContext)
}

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null)
  const [loading, setLoading] = useState(true)

  // Try to restore session from refresh token on mount
  useEffect(() => {
    async function tryRefresh() {
      try {
        const data = await refreshTokenApi()
        setAccessToken(data.accessToken)
        setUser(data.user)
      } catch {
        // No valid refresh token — user needs to login
        setAccessToken(null)
        setUser(null)
      } finally {
        setLoading(false)
      }
    }
    tryRefresh()
  }, [])

  const login = useCallback((accessToken: string, authUser: AuthUser) => {
    setAccessToken(accessToken)
    setUser(authUser)
  }, [])

  const logout = useCallback(async () => {
    try {
      await logoutApi()
    } catch {
      // Ignore — clear local state regardless
    }
    setAccessToken(null)
    setUser(null)
  }, [])

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  )
}
```

**Step 2: Verify client compiles**

```bash
cd client && npx tsc --noEmit
```

Expected: 0 errors

**Step 3: Commit**

```bash
git add client/src/contexts/AuthContext.tsx
git commit -m "feat(client): AuthContext with JWT session restore + login/logout"
```

---

### Task 6: Login + VerifyOtp Pages (client)

**Files:**
- Create: `client/src/pages/Login.tsx`
- Create: `client/src/pages/VerifyOtp.tsx`

**Step 1: Create Login page** — phone number input form

```tsx
// client/src/pages/Login.tsx
import { useState, FormEvent } from 'react'
import { useNavigate } from 'react-router-dom'
import { sendOtp } from '@/api/auth'
import { Button } from '@/components/ui/Button'
import { Input } from '@/components/ui/Input'

export default function Login() {
  const [phone, setPhone] = useState('')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const navigate = useNavigate()

  async function handleSubmit(e: FormEvent) {
    e.preventDefault()
    setError('')

    const cleanPhone = phone.replace(/\D/g, '').slice(-10)
    if (cleanPhone.length !== 10) {
      setError('Enter a valid 10-digit phone number')
      return
    }

    const fullPhone = `+91${cleanPhone}`
    setLoading(true)
    try {
      await sendOtp(fullPhone)
      navigate('/verify', { state: { phone: fullPhone } })
    } catch (err: any) {
      setError(err.response?.data?.error || 'Failed to send OTP')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen flex flex-col items-center justify-center px-6">
      <div className="w-full max-w-sm">
        <div className="text-center mb-8">
          <h1 className="text-3xl font-bold text-accent-orange mb-2">GymRep</h1>
          <p className="text-text-secondary">Your Gym, Upgraded</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm text-text-secondary mb-1.5">Phone Number</label>
            <div className="flex gap-2">
              <div className="bg-bg-card border border-border-light rounded-xl px-4 py-3 text-sm text-text-secondary">
                +91
              </div>
              <Input
                type="tel"
                inputMode="numeric"
                placeholder="9999999999"
                value={phone}
                onChange={(e) => setPhone(e.target.value.replace(/\D/g, '').slice(0, 10))}
                autoFocus
              />
            </div>
          </div>

          {error && <p className="text-status-red text-sm">{error}</p>}

          <Button type="submit" fullWidth loading={loading} disabled={phone.replace(/\D/g, '').length < 10}>
            Send OTP
          </Button>
        </form>

        <p className="text-center text-text-muted text-xs mt-6">
          We'll send a 6-digit code to verify your number
        </p>
      </div>
    </div>
  )
}
```

**Step 2: Create VerifyOtp page** — 6-digit OTP input with auto-submit

```tsx
// client/src/pages/VerifyOtp.tsx
import { useState, useRef, useEffect, KeyboardEvent, ClipboardEvent } from 'react'
import { useNavigate, useLocation } from 'react-router-dom'
import { verifyOtp } from '@/api/auth'
import { useAuth } from '@/contexts/AuthContext'
import { Button } from '@/components/ui/Button'

export default function VerifyOtp() {
  const [otp, setOtp] = useState(['', '', '', '', '', ''])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState('')
  const inputsRef = useRef<(HTMLInputElement | null)[]>([])
  const navigate = useNavigate()
  const location = useLocation()
  const { login } = useAuth()

  const phone = (location.state as any)?.phone
  if (!phone) {
    navigate('/login', { replace: true })
    return null
  }

  useEffect(() => {
    inputsRef.current[0]?.focus()
  }, [])

  async function handleVerify(otpString: string) {
    setError('')
    setLoading(true)
    try {
      const data = await verifyOtp(phone, otpString)
      login(data.accessToken, data.user)
      // Redirect based on role
      if (data.user.role === 'owner') {
        navigate('/owner', { replace: true })
      } else {
        navigate('/m', { replace: true })
      }
    } catch (err: any) {
      setError(err.response?.data?.error || 'Invalid OTP')
      setOtp(['', '', '', '', '', ''])
      inputsRef.current[0]?.focus()
    } finally {
      setLoading(false)
    }
  }

  function handleChange(index: number, value: string) {
    if (!/^\d*$/.test(value)) return

    const newOtp = [...otp]
    newOtp[index] = value.slice(-1)
    setOtp(newOtp)

    // Auto-advance to next input
    if (value && index < 5) {
      inputsRef.current[index + 1]?.focus()
    }

    // Auto-submit when all 6 digits entered
    const fullOtp = newOtp.join('')
    if (fullOtp.length === 6) {
      handleVerify(fullOtp)
    }
  }

  function handleKeyDown(index: number, e: KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Backspace' && !otp[index] && index > 0) {
      inputsRef.current[index - 1]?.focus()
    }
  }

  function handlePaste(e: ClipboardEvent) {
    e.preventDefault()
    const pasted = e.clipboardData.getData('text').replace(/\D/g, '').slice(0, 6)
    if (pasted.length === 6) {
      const newOtp = pasted.split('')
      setOtp(newOtp)
      handleVerify(pasted)
    }
  }

  return (
    <div className="min-h-screen flex flex-col items-center justify-center px-6">
      <div className="w-full max-w-sm">
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-text-primary mb-2">Enter OTP</h1>
          <p className="text-text-secondary text-sm">
            Sent to {phone.replace('+91', '')}
          </p>
        </div>

        <div className="flex justify-center gap-3 mb-6">
          {otp.map((digit, i) => (
            <input
              key={i}
              ref={(el) => { inputsRef.current[i] = el }}
              type="tel"
              inputMode="numeric"
              maxLength={1}
              value={digit}
              onChange={(e) => handleChange(i, e.target.value)}
              onKeyDown={(e) => handleKeyDown(i, e)}
              onPaste={i === 0 ? handlePaste : undefined}
              className="w-12 h-14 bg-bg-card border border-border-light rounded-xl text-center text-xl font-bold text-text-primary focus:outline-none focus:border-accent-orange transition-colors"
              disabled={loading}
            />
          ))}
        </div>

        {error && <p className="text-status-red text-sm text-center mb-4">{error}</p>}

        <Button
          fullWidth
          loading={loading}
          disabled={otp.join('').length < 6}
          onClick={() => handleVerify(otp.join(''))}
        >
          Verify
        </Button>

        <button
          className="w-full text-center text-text-muted text-sm mt-4 py-2"
          onClick={() => navigate('/login')}
          disabled={loading}
        >
          Change phone number
        </button>
      </div>
    </div>
  )
}
```

**Step 3: Verify client compiles**

```bash
cd client && npx tsc --noEmit
```

Expected: 0 errors

**Step 4: Commit**

```bash
git add client/src/pages/Login.tsx client/src/pages/VerifyOtp.tsx
git commit -m "feat(client): Login + VerifyOtp pages with OTP auto-submit"
```

---

### Task 7: ProtectedRoute + Router Setup (client)

**Files:**
- Create: `client/src/components/shared/ProtectedRoute.tsx`
- Create: `client/src/pages/owner/Dashboard.tsx` (placeholder)
- Create: `client/src/pages/member/Home.tsx` (placeholder)
- Modify: `client/src/App.tsx` — full router with auth guards
- Modify: `client/src/main.tsx` — wrap with AuthProvider

**Step 1: Create ProtectedRoute component**

```tsx
// client/src/components/shared/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'
import { LoadingSpinner } from './LoadingSpinner'

interface ProtectedRouteProps {
  children: React.ReactNode
  requiredRole?: 'owner' | 'member'
}

export function ProtectedRoute({ children, requiredRole }: ProtectedRouteProps) {
  const { user, loading } = useAuth()

  if (loading) {
    return <LoadingSpinner text="Checking auth..." />
  }

  if (!user) {
    return <Navigate to="/login" replace />
  }

  if (requiredRole && user.role !== requiredRole) {
    // Wrong role — redirect to their correct area
    return <Navigate to={user.role === 'owner' ? '/owner' : '/m'} replace />
  }

  return <>{children}</>
}
```

**Step 2: Create owner Dashboard placeholder**

```tsx
// client/src/pages/owner/Dashboard.tsx
import { useAuth } from '@/contexts/AuthContext'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'

export default function OwnerDashboard() {
  const { user, logout } = useAuth()

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Owner Dashboard</h1>
      <Card>
        <p className="text-text-secondary text-sm">Logged in as</p>
        <p className="text-lg font-semibold">{user?.full_name || user?.phone}</p>
        <p className="text-text-muted text-sm">Role: {user?.role}</p>
      </Card>
      <Card variant="alert-info">
        <p className="text-sm">Owner features coming in M2. Auth is working!</p>
      </Card>
      <Button variant="danger" fullWidth onClick={logout}>
        Logout
      </Button>
    </div>
  )
}
```

**Step 3: Create member Home placeholder**

```tsx
// client/src/pages/member/Home.tsx
import { useAuth } from '@/contexts/AuthContext'
import { Card } from '@/components/ui/Card'
import { Button } from '@/components/ui/Button'

export default function MemberHome() {
  const { user, logout } = useAuth()

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Welcome back!</h1>
      <Card>
        <p className="text-text-secondary text-sm">Logged in as</p>
        <p className="text-lg font-semibold">{user?.full_name || user?.phone}</p>
        <p className="text-text-muted text-sm">Role: {user?.role}</p>
      </Card>
      <Card variant="alert-info">
        <p className="text-sm">Member features coming in M3. Auth is working!</p>
      </Card>
      <Button variant="danger" fullWidth onClick={logout}>
        Logout
      </Button>
    </div>
  )
}
```

**Step 4: Update App.tsx** — full router setup

```tsx
// client/src/App.tsx
import { Routes, Route, Navigate } from 'react-router-dom'
import { useAuth } from '@/contexts/AuthContext'
import { ProtectedRoute } from '@/components/shared/ProtectedRoute'
import { LoadingSpinner } from '@/components/shared/LoadingSpinner'
import Login from '@/pages/Login'
import VerifyOtp from '@/pages/VerifyOtp'
import OwnerDashboard from '@/pages/owner/Dashboard'
import MemberHome from '@/pages/member/Home'

function RootRedirect() {
  const { user, loading } = useAuth()
  if (loading) return <LoadingSpinner />
  if (!user) return <Navigate to="/login" replace />
  return <Navigate to={user.role === 'owner' ? '/owner' : '/m'} replace />
}

export default function App() {
  return (
    <div className="max-w-mobile mx-auto min-h-screen">
      <Routes>
        {/* Public */}
        <Route path="/" element={<RootRedirect />} />
        <Route path="/login" element={<Login />} />
        <Route path="/verify" element={<VerifyOtp />} />

        {/* Owner */}
        <Route path="/owner" element={
          <ProtectedRoute requiredRole="owner">
            <OwnerDashboard />
          </ProtectedRoute>
        } />

        {/* Member */}
        <Route path="/m" element={
          <ProtectedRoute requiredRole="member">
            <MemberHome />
          </ProtectedRoute>
        } />

        {/* Catch-all */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </div>
  )
}
```

**Step 5: Update main.tsx** — wrap with AuthProvider

```tsx
// client/src/main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import { AuthProvider } from '@/contexts/AuthContext'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <AuthProvider>
        <App />
      </AuthProvider>
    </BrowserRouter>
  </React.StrictMode>
)
```

**Step 6: Verify client compiles**

```bash
cd client && npx tsc --noEmit
```

Expected: 0 errors

**Step 7: Commit**

```bash
git add client/src/
git commit -m "feat(client): ProtectedRoute, router setup, auth-gated placeholder pages"
```

---

## QA Gate (M1)

After all tasks are complete, verify:

1. `cd server && npx tsc --noEmit` → 0 errors
2. `cd client && npx tsc --noEmit` → 0 errors
3. Start both: `npm run dev` (needs MongoDB URI in server/.env)
4. Test auth flow via curl:
   ```bash
   # Send OTP
   curl -X POST http://localhost:5000/api/auth/send-otp \
     -H "Content-Type: application/json" \
     -d '{"phone":"+919999999999"}'
   # Expected: {"success":true,"message":"OTP sent (test mode)"}

   # Verify OTP
   curl -X POST http://localhost:5000/api/auth/verify-otp \
     -H "Content-Type: application/json" \
     -d '{"phone":"+919999999999","otp":"123456"}' \
     -c cookies.txt
   # Expected: {"accessToken":"eyJ...","user":{"id":"...","phone":"+919999999999","role":"member","full_name":null}}

   # Refresh
   curl -X POST http://localhost:5000/api/auth/refresh \
     -b cookies.txt
   # Expected: new accessToken + user

   # Logout
   curl -X POST http://localhost:5000/api/auth/logout \
     -b cookies.txt
   # Expected: {"success":true}
   ```
5. Browser at localhost:5173:
   - `/` redirects to `/login`
   - Login with 9999999999 → OTP page → enter 123456 → lands on `/m` (member home)
   - Logout → back to `/login`
   - Refresh page → auto-restores session (no re-login needed)

If all pass → M1 is complete. Save memory and proceed to M2.
